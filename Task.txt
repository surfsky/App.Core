
            foreach (var header in headers)
            {
                var key = header.Key;
                var value = header.Value;
                if (!WebHeaderCollection.IsRestricted(key))
                    request.Headers.Add(key, value);
                else
                {
                    /*
                    手动设置限制标头：
                    Host由系统设置为当前主机信息。
                    Referer由 Referer 属性设置。
                    User-Agent由 UserAgent 属性设置。
                    Accept由 Accept 属性设置。
                    Connection由 Connection 属性和 KeepAlive 属性设置。
                    Range HTTP标头是通过AddRange来添加手工
                    If-Modified-Since HTTP标头通过IfModifiedSince 属性设置
                    Content-Length由 ContentLength 属性设置。
                    Content-Type由 ContentType 属性设置。
                    Expect由 Expect 属性设置。
                    Date由 Date属性设置，默认为系统的当前时间。
                    Transfer-Encoding由 TransferEncoding 属性设置（SendChunked 属性必须为 true）。
                    */
                    var k = key.ToLower();
                    if (k == "host")             request.Host = value;
                    else if (k == "referer")     request.Referer = value;
                    else if (k == "user-agent")  request.UserAgent = value;
                    else if (k == "accept")      request.Accept = value;
                    else if (k == "connection")  request.Connection = value;
                }
            }

			
    /// <summary>
    /// 自定义的请求头部处理，对于受限制头部（如Host, Referer等）可直接赋值而不报异常
    /// </summary>
    internal class FreeWebHeaders : WebHeaderCollection
    {
        public override void Add(string name, string value)
        {
            base.AddWithoutValidate(name, value);
        }
    }
	            // 会报错“”
            //FreeWebHeaders h = new FreeWebHeaders();
            //foreach (var header in headers)
            //    h.Add(header.Key, header.Value);
            //request.Headers = h;


                        //return text.IsEmpty() ? null : new DateTime?(DateTime.Parse(text));
                                    //return text.IsEmpty() ? null : new decimal?(decimal.Parse(text));
                                                //return text.IsEmpty() ? null : new double?(double.Parse(text));
            //return text.IsEmpty() ? null : new float?(float.Parse(text));
                        //return text.IsEmpty() ? null : new Int64?(Int64.Parse(text));
            //return text.IsEmpty() ? null : new UInt64?(UInt64.Parse(text));
                        //return text.IsEmpty() ? null : new Int32?(Int32.Parse(text));
            //return txt.IsEmpty() ? null : new Int16?(Int16.Parse(text));
                        //return text.IsEmpty() ? null : new bool?(Boolean.Parse(text));

                                    if (RegexHelper.IsMatch(text, RegexHelper.Integer))
            {
                int n = int.Parse(text);
                return (T)Enum.ToObject(typeof(T), n);
            }
            else
            {
            }

            /// <summary>解析文件扩展名</summary>
        public static string ParseFileExtension(string file)
        {
            /*
            string pattern = @"^(.*)(.)(.*)$";
            Regex r = new Regex(pattern);
            Match m = r.Match(file);
            if (m.Success && m.Groups.Count >= 3)
                return m.Groups[3].Value;
            return null;
            */
            int n = file.LastIndexOf('.');
            if (n != -1)
                return file.Substring(n);
            return "";
        }
